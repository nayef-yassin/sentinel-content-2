{
  "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
  "contentVersion": "1.0.0.0",
  "parameters": {
    "workspace": {
      "type": "String"
    }
  },
  "resources": [
    {
      "type": "Microsoft.OperationalInsights/workspaces/savedSearches",
      "apiVersion": "2020-08-01",
      "name": "[concat(parameters('workspace'), '/PermutationsOnLogonNames')]",
      "location": "[resourceGroup().location]",
      "properties": {
        "eTag": "*",
        "displayName": "Permutations on logon attempts by UserPrincipalNames indicating potential brute force",
        "category": "Hunting Queries",
        "query": "\nlet fl_Min = 3;\nlet un_MatchMin = 2;\nlet upnFunc = (tableName:string){\ntable(tableName) \n| extend Operation = columnifexists(\"Operation\", \"Sign-in activity\")\n| where Operation == \"UserLoginFailed\" or Operation == \"Sign-in activity\"\n| extend Result = columnifexists(\"ResultType\", \"tempValue\")\n| extend Result = iff(Result == \"tempValue\", columnifexists(\"ResultStatus\", Result), Result)\n| extend ResultValue = case(Result == \"0\", \"Success\", Result == \"Success\" or Result == \"Succeeded\", \"Success\", Result)\n| where ResultValue != \"Success\"\n| extend UserPrincipalName = columnifexists(\"UserPrincipalName\", \"tempValue\") \n| extend UserPrincipalName = iff(tableName == \"OfficeActivity\", tolower(UserId), tolower(UserPrincipalName))\n| extend UPN = split(UserPrincipalName, \"@\")\n| extend UserNameOnly = tostring(UPN[0]), DomainOnly = tostring(UPN[1])\n| where UserNameOnly contains \".\" or UserPrincipalName contains \"-\" or UserPrincipalName contains \"_\"\n// Verify we only get accounts without other separators, it would be difficult to identify multi-level separators\n// Count of any that are not alphanumeric\n| extend charcount = countof(UserNameOnly, '[^0-9A-Za-z]', \"regex\")\n// Drop any that have non-alphanumeric characters still included\n| where charcount < 2\n// Creating array of name pairs that include the separators we are interested in, this can be added to if needed.\n| extend unoArray = case(\nUserNameOnly contains \".\", split(UserNameOnly, \".\"),\nUserNameOnly contains \"-\", split(UserNameOnly, \"-\"),\nUserNameOnly contains \"_\", split(UserNameOnly, \"_\"),\nUserNameOnly)\n| extend First = iff(isnotempty(tostring(parse_json(unoArray)[0])), tostring(parse_json(unoArray)[0]),tostring(unoArray))\n| extend Last = tostring(parse_json(unoArray)[1])\n| extend First4char = iff(countof(substring(First, 0,4), '[0-9A-Za-z]', \"regex\") >= 4, substring(First, 0,4), \"LessThan4\"),\nFirst6char = iff(countof(substring(First, 0,6), '[0-9A-Za-z]', \"regex\") >= 6, substring(First, 0,6), \"LessThan6\"),\nFirst8char = iff(countof(substring(First, 0,8), '[0-9A-Za-z]', \"regex\") >= 8, substring(First, 0,8), \"LessThan8\"),\nLast4char = iff(countof(substring(Last, 0,4), '[0-9A-Za-z]', \"regex\") >= 4, substring(Last, 0,4), \"LessThan4\"),\nLast6char = iff(countof(substring(Last, 0,6), '[0-9A-Za-z]', \"regex\") >= 6, substring(Last, 0,6), \"LessThan6\"),\nLast8char = iff(countof(substring(Last, 0,8), '[0-9A-Za-z]', \"regex\") >= 8, substring(Last, 0,8), \"LessThan8\")\n| where First != Last\n| summarize UserNames = makeset(UserNameOnly),\nfl_Count = count() by bin(TimeGenerated, 10m), First4char, First6char, First8char, Last4char, Last6char, Last8char, Type\n};\nlet SigninList = upnFunc(\"SigninLogs\");\nlet OffActList = upnFunc(\"OfficeActivity\");\nlet UserNameList = (union isfuzzy=true SigninList, OffActList);\nlet Char4List = UserNameList\n| project TimeGenerated, First4char, Last4char, UserNames, fl_Count, Type\n| where First4char != \"LessThan4\" and Last4char != \"LessThan4\";\n// Break out first and last so we can then join and see where a first and last match.\nlet First4charList = Char4List | where isnotempty(First4char)\n| summarize un_MatchOnFirst = makeset(UserNames),\nfl_CountForFirst = sum(fl_Count) by TimeGenerated, CharSet = First4char, Type\n| project TimeGenerated, CharSet, un_MatchOnFirst, un_MatchOnFirstCount = array_length(un_MatchOnFirst), fl_CountForFirst, Type;\nlet Last4charList = Char4List | where isnotempty(Last4char) \n| summarize un_MatchOnLast = makeset(UserNames), fl_CountForLast = sum(fl_Count) by TimeGenerated, CharSet = Last4char, Type\n| project TimeGenerated, CharSet, un_MatchOnLast, un_MatchOnLastCount = array_length(un_MatchOnLast), fl_CountForLast, Type;\nlet char4 = First4charList | join Last4charList on CharSet and TimeGenerated\n| project-away TimeGenerated1, CharSet1\n// Make sure that we get more than a single match for First or Last\n| where un_MatchOnFirstCount >= un_MatchMin or un_MatchOnLastCount >= un_MatchMin\n| where fl_CountForFirst >= fl_Min or fl_CountForLast >= fl_Min;\nlet Char6List = UserNameList\n| project TimeGenerated, First6char, Last6char, UserNames, fl_Count, Type\n| where First6char != \"LessThan6\" and Last6char != \"LessThan6\";\n// Break out first and last so we can then join and see where a first and last match.\nlet First6charList = Char6List | where isnotempty(First6char)\n| summarize un_MatchOnFirst = makeset(UserNames), fl_CountForFirst = sum(fl_Count) by TimeGenerated, CharSet = First6char, Type\n| project TimeGenerated, CharSet, un_MatchOnFirst, un_MatchOnFirstCount = array_length(un_MatchOnFirst), fl_CountForFirst, Type;\nlet Last6charList = Char6List | where isnotempty(Last6char)\n| summarize un_MatchOnLast = makeset(UserNames), fl_CountForLast = sum(fl_Count) by TimeGenerated, CharSet = Last6char, Type\n| project TimeGenerated, CharSet, un_MatchOnLast, un_MatchOnLastCount = array_length(un_MatchOnLast), fl_CountForLast, Type;\nlet char6 = First6charList | join Last6charList on CharSet and TimeGenerated\n| project-away TimeGenerated1, CharSet1\n// Make sure that we get more than a single match for First or Last\n| where un_MatchOnFirstCount >= un_MatchMin or un_MatchOnLastCount >= un_MatchMin\n| where fl_CountForFirst >= fl_Min or fl_CountForLast >= fl_Min;\nlet Char8List = UserNameList\n| project TimeGenerated, First8char, Last8char, UserNames, fl_Count, Type\n| where First8char != \"LessThan8\" and Last8char != \"LessThan8\";\n// Break out first and last so we can then join and see where a first and last match.\nlet First8charList = Char8List | where isnotempty(First8char)\n| summarize un_MatchOnFirst = makeset(UserNames), fl_CountForFirst = sum(fl_Count) by TimeGenerated, CharSet = First8char, Type\n| project TimeGenerated, CharSet, un_MatchOnFirst, un_MatchOnFirstCount = array_length(un_MatchOnFirst), fl_CountForFirst, Type; \nlet Last8charList = Char8List | where isnotempty(Last8char)\n| summarize un_MatchOnLast = makeset(UserNames), fl_CountForLast = sum(fl_Count) by TimeGenerated, CharSet = Last8char, Type\n| project TimeGenerated, CharSet, un_MatchOnLast, un_MatchOnLastCount = array_length(un_MatchOnLast), fl_CountForLast, Type;\nlet char8 = First8charList | join Last8charList on CharSet and TimeGenerated\n| project-away TimeGenerated1, CharSet1\n// Make sure that we get more than a single match for First or Last\n| where un_MatchOnFirstCount >= un_MatchMin or un_MatchOnLastCount >= un_MatchMin\n| where fl_CountForFirst >= fl_Min or fl_CountForLast >= fl_Min;\n(union isfuzzy=true char4, char6, char8)\n| project Type, TimeGenerated, CharSet, UserNameMatchOnFirst = un_MatchOnFirst, UserNameMatchOnFirstCount = un_MatchOnFirstCount,\nFailedLogonCountForFirst = fl_CountForFirst, UserNameMatchOnLast = un_MatchOnLast, UserNameMatchOnLastCount = un_MatchOnLastCount,\nFailedLogonCountForLast = fl_CountForLast\n| sort by UserNameMatchOnFirstCount desc, UserNameMatchOnLastCount desc\n| extend timestamp = TimeGenerated\n",
        "version": 1,
        "tags": [
          {
            "name": "description",
            "value": "Attackers sometimes try variations on account logon names, this will identify failed attempts on logging in using permutations \nbased on known first and last name within 10m time windows, for UserPrincipalNames that separated by hyphen(-), "
          },
          {
            "name": "tactics",
            "value": "CredentialAccess"
          },
          {
            "name": "relevantTechniques",
            "value": "T1110"
          }
        ]
      }
    }
  ]
}
